# VSDHDP
VSDHDP

# Day 0
Checking yosys

![](Day0/yosys.PNG)

Checking ngspice

![](Day0/ngspice.PNG)

Checking sta

![](Day0/sta.PNG)

Checking iverilog

![](Day0/iverilog.PNG)

Checking gtkwave

![](Day0/gtkwave.PNG)

# Day 1 - Introduction to Verilog RTL design and Synthesis

Run iverilog and gtkwave on good_mux.v

![](Day1/good_mux.PNG)

Run yosys
```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

![](Day1/yosys1.PNG)

Read verilog file and run synth
```
yosys> read_verilog good_mux.v
yosys> synth -top good_mux
```

![](Day1/yosys2.PNG)

Run abc - generate the gate netlist

```
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> show
```
Loos like libs contain cell mux

![](Day1/yosys3.PNG)


## Comand to write netlist

`noattr` - reduce netlist, easier to read.
```
write_verilog -noattr good_mux_netlist.v
!gvim good_mux_netlist.v
```


# Day 2 Timing Libs, Heirarchial vs Flat Synthesis And Efficient Flop Coding Styles

Libs syntax manual https://people.eecs.berkeley.edu/~alanmi/publications/other/liberty07_03.pdf

Libs files contain information about e.g. capacitance or leakage current or areafor each cell and for each version after PVT

PVT is the Process, Voltage, and Temperature.

![](Day2/PVT.jpg)

## Hierarchical vs Flat Synthesis

Example of multimodules

![](Day2/module.PNG)

Run yosys:

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 

1. Executing Liberty frontend.
Imported 428 cell types from liberty file.

yosys> read_verilog multiple_modules.v

2. Executing Verilog-2005 frontend: multiple_modules.v
Parsing Verilog input from `multiple_modules.v' to AST representation.
Generating RTLIL representation for module `\sub_module2'.
Generating RTLIL representation for module `\sub_module1'.
Generating RTLIL representation for module `\multiple_modules'.
Successfully finished Verilog frontend.

yosys> synth -top multiple_modules

...
3.25. Printing statistics.

=== multiple_modules ===

   Number of wires:                  5
   Number of wire bits:              5
   Number of public wires:           5
   Number of public wire bits:       5
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     sub_module1                     1
     sub_module2                     1

=== sub_module1 ===

   Number of wires:                  3
   Number of wire bits:              3
   Number of public wires:           3
   Number of public wire bits:       3
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_AND_                          1

=== sub_module2 ===

   Number of wires:                  3
   Number of wire bits:              3
   Number of public wires:           3
   Number of public wire bits:       3
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_OR_                           1

=== design hierarchy ===

   multiple_modules                  1
     sub_module1                     1
     sub_module2                     1

   Number of wires:                 11
   Number of wire bits:             11
   Number of public wires:          11
   Number of public wire bits:      11
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $_AND_                          1
     $_OR_                           1

3.26. Executing CHECK pass (checking for obvious problems).
Checking module multiple_modules...
Checking module sub_module1...
Checking module sub_module2...
Found and reported 0 problems.


yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

yosys> show

5. Generating Graphviz representation of design.
ERROR: For formats different than 'ps' or 'dot' only one module must be selected.

yosys> show multiple_modules 
```

We got a hierarchical view instead of a view of the gates

![](Day2/test1.PNG)

Write netlist

```
yosys> write_verilog -noattr multiple_module_hier.v
yosys> !gvim multiple_modules_hier.v 
```


My netlist
```
/* Generated by Yosys 0.7 (git sha1 61f6811, gcc 6.2.0-11ubuntu1 -O2 -fdebug-prefix-map=/build/yosys-OIL3SR/yosys-0.7=. -fstack-protector-strong -fPIC -Os) */

module multiple_modules(a, b, c, y);
  input a;
  input b;
  input c;
  wire net1;
  output y;
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  input b;

```

No We write flat version of the netlist

```
yosys> flatten
yosys> write_verilog -noattr multiple_modules_flat.v
yosys> !gvim multiple_modules_flat.v
```

Now netlist is shorter

```
/* Generated by Yosys 0.23+35 (git sha1 23e26ff66, clang 14.0.0-1ubuntu1 -fPIC -Os) */

module multiple_modules(a, b, c, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire _4_;
  wire _5_;
  input a;
  wire a;
  input b;
  wire b;
  input c;
  wire c;
  wire net1;
  wire \u1.a ;
  wire \u1.b ;
  wire \u1.y ;
  wire \u2.a ;
  wire \u2.b ;
  wire \u2.y ;
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _6_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  sky130_fd_sc_hd__lpflow_inputiso1p_1 _7_ (
    .A(_4_),
    .SLEEP(_3_),
    .X(_5_)
  );
  assign _4_ = \u2.b ;
  assign _3_ = \u2.a ;
  assign \u2.y  = _5_;
  assign \u2.a  = net1;
  assign \u2.b  = c;
  assign y = \u2.y ;
  assign _1_ = \u1.b ;
  assign _0_ = \u1.a ;
  assign \u1.y  = _2_;
  assign \u1.a  = a;
  assign \u1.b  = b;
  assign net1 = \u1.y ;
endmodule

```

![](Day2/flat.PNG)

## Sub-Module Level Synthesi

Sub-module synthesis is useful when one of the modules appears multiple times and you don't want to synthesize it multiple times.
It is also useful when dividing the system into smaller parts, e.g. when the tool itself does not give good results.


Application example:


```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog multiple_modules.v
yosys> synth -top multiple_modules 
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> flatten
yosys> show 
```

![](Day2/flat2.PNG)

Now we can control which module to syntesis


```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog multiple_modules.v
yosys> synth -top sub_module1 
```

We control sub-module name by using `synth -top "module_name"`

```
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> show 
```

![](Day2/sub_module1.PNG)

## Various Flop Coding Styles and optimization


How to avoid glitch in combinational logic?

To avoid glitch we use flops.


Asynchronous reset: the reset signal does not wait for a clock edge, the output is updated to 0.

Asynchronous set: the set signal does not wait for a clock edge, the output is updated to 1.

A synchronous set or reset is performed relative to the clock edge.

Async reset:

```
$ iverilog dff_asyncres.v tb_dff_asyncres.v
$ ./a.out
$ gtkwave tb_dff_asyncres.vcd
```

![](Day2/asyncres.PNG)

Async set:

```
$ iverilog dff_async_set.v tb_dff_async_set.v
$ ./a.out
$ gtkwave tb_dff_async_set.vcd
```


![](Day2/asyncset.PNG)

Sync reset:

```
$ iverilog dff_syncres.v tb_dff_syncres.v 
$ ./a.out 
$ gtkwave tb_dff_syncres.vc
```


![](Day2/syncres.PNG)


Async reset synthesis.

```
yosys> read_liberty -lib ../lib sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog dff_asyncres.v
yosys> synth -top dff_asyncres
```

In flow flops can be in other library. Now we load flops.

```
yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> show
```

![](Day2/dffasync.PNG)

## Sync optimization

Optimizing, for example, multiplication by 2 is really a bit shift operation.

![](Day2/mult.PNG)

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog mult_2.v
yosys> synth -top mul2

.25. Printing statistics.

=== mul2 ===

   Number of wires:                  2
   Number of wire bits:              7
   Number of public wires:           2
   Number of public wire bits:       7
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  0

4.26. Executing CHECK pass (checking for obvious problems).
Checking module mul2...
Found and reported 0 problems.

```

We don't get hardware/cell for this verilog code.

```
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> show
```

![](Day2/mul2.PNG)

# Day 3


In this part of the course, we learned about:

Introduction to Logic Optimisations
- Combinational Logic optimisation: (reduce power and area)
We can use direct optimisation, boolen logic optimisation.
- Sequential logic optimisations
Sequential constant propagation: retiming, sequential logic cloning




## Combinational Logic Optimization

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog opt_check.v

yosys> synth -top opt_check


3.25. Printing statistics.

=== opt_check ===

   Number of wires:                  3
   Number of wire bits:              3
   Number of public wires:           3
   Number of public wire bits:       3
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_AND_                          1

3.26. Executing CHECK pass (checking for obvious problems).
Checking module opt_check...
Found and reported 0 problems.

yosys> opt_clean -purge

4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \opt_check..


yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

```

We get:
![](Day3/opt1.PNG)

```
yosys> read_verilog opt_check2.v
yosys> synth -top opt_check2
yosys> opt_clean -purge
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
We get:

![](Day3/opt2.PNG)

Next example:

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog opt_check3.v
yosys> synth -top opt_check3
yosys> opt_clean -purge
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

```

![](Day3/opt3.PNG)

For the next modules, before opt -purge, you need to do flatten so that the whole optimization is correct.

## Sequential Logic Optimisations

We learn sequential optimisations on a few examples dff*.

For example diference on dff_const1.v and dff_const2.v.
Verilog showed differences in the behavior of the Q signal after the reset.


![](Day3/dff_1vs2.PNG)


run  example:
```
$ iverilog dff_const1.v tb_dff_const1.v
$ ./a.out 
$ $ gtkwave tb_dff_const1.vcd &
```

![](Day3/dff1.PNG)

Q wait for edg of the clock.

dff_const2 will no wait for clock edge to set Q.


```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog dff_const1.v
yosys> synth -top dff_const1

3.25. Printing statistics.

=== dff_const1 ===

   Number of wires:                  3
   Number of wire bits:              3
   Number of public wires:           3
   Number of public wire bits:       3
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_DFF_PP0_                      1

yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib

.1.2. Re-integrating ABC results.
ABC RESULTS:   sky130_fd_sc_hd__clkinv_1 cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        1
ABC RESULTS:          output signals:        1
Removing temp directory.

yosys> show
```

![](Day3/dff1s.PNG)

When the above steps are repeated for dff_const2.v the logic will be simplified.


![](Day3/dff2s.PNG)


Example dff_const3.v

Verilog file:
```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
        if(reset)
        begin
                q <= 1'b1;
                q1 <= 1'b0;
        end
        else
        begin
                q1 <= 1'b1;
                q <= q1;
        end
end
```

So Logic can look like this. We need to check if it has been optimized
![](Day3/dff3.PNG)

Run check.

```
$ iverilog dff_const3.v tb_dff_const3.v
$ ./a.out 
VCD info: dumpfile tb_dff_const3.vcd opened for output.
$ gtkwave tb_dff_const3.vcd

```
![](Day3/dff3_iv.PNG)

Run yosys:
```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog dff_const3.v
yosys> synth -top dff_const3
...
=== dff_const3 ===

   Number of wires:                  4
   Number of wire bits:              4
   Number of public wires:           4
   Number of public wire bits:       4
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  2
     $_DFF_PP0_                      1
     $_DFF_PP1_                      1

yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
...
5.1.2. Re-integrating ABC results.
ABC RESULTS:   sky130_fd_sc_hd__clkinv_1 cells:        2
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        1
ABC RESULTS:          output signals:        2
Removing temp directory.

yosys> show
```
![](Day3/dff3s.PNG)

## Seq optimisation unused outputs.

Logic that does not affect the output of the circuit will be simplified and eliminated.

In this example we can see how circuit can be optimized.

![](Day3/optcout.PNG)

Now we modified ciruit to use all cout signal.

Check for update couter_opt

```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = (count[2:0] == 3'b100);

always @(posedge clk ,posedge reset)
begin
        if(reset)
                count <= 3'b000;
        else
                count <= count + 1;
end

endmodule

```



```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog counter_opt2.v
yosys> synth -top counter_opt
...
=== counter_opt ===

   Number of wires:                  8
   Number of wire bits:             14
   Number of public wires:           4
   Number of public wire bits:       6
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  9
     $_ANDNOT_                       1
     $_AND_                          1
     $_DFF_PP0_                      3
     $_NOT_                          1
     $_OR_                           1
     $_XOR_                          2

We expect 3 flops.

yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
...
7.1.2. Re-integrating ABC results.
ABC RESULTS:   sky130_fd_sc_hd__nor3b_1 cells:        1
ABC RESULTS:   sky130_fd_sc_hd__nand2_1 cells:        1
ABC RESULTS:   sky130_fd_sc_hd__xor2_1 cells:        1
ABC RESULTS:   sky130_fd_sc_hd__xnor2_1 cells:        1
ABC RESULTS:   sky130_fd_sc_hd__clkinv_1 cells:        4
ABC RESULTS:        internal signals:        2
ABC RESULTS:           input signals:        4
ABC RESULTS:          output signals:        7

```

![](Day3/opt_couts.PNG)



# Day 4


## Gate level simulations, Non blocking and blocking assignments, Synthesis-Simulation mismatch.



What is GLS? (Gate Level Simulation)
* Running the test bench with Netlist as Design Under Test
* Netlist is logically same as RTL Code
* Same Tes Bench will align with the Design

Why GLS?
* Verify the logical correctness of design after synthesis
* Ensuring the timing of the design is met.
* For this GLS needs to run with delay annotation.


GLS using IVERILOG

![](Day4/gls.PNG)

Note:
```
If the Gate Levwl Models are delay annotated, then we can use GLS for timing validation
```

Synthesis Simulation Mismatch
* Missing sensitivity List
* Blocking vs Non-Blocking Assigments
* Non Standard Verilog Coding

Missing sensitivity List:
Simulator works by looking on inputs if inputs don't change output will settle.
For example in module mux we have always @(sel) but but it is not sensitivity to all imputs but only to sel it should be always @(*) to be sensitivity to all imputs.

Blocking vs Non-Blocking Assigments:
- Inside always block
- = ->Blocking
	- Executes the statments in the order it is written
	- So the first statement is evaluated before the second statment
- <= Non Blocking

	-Executes all the RHS when always block is entered adn assigns to LHS
	- Parallel evaluation



ternary_operator_mux:
```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
        assign y = sel?i1:i0;
        endmodule
```

Run iverilog:
```
$ iverilog ternary_operator_mux.v tb_ternary_operator_mux.v
$ ./a.out 
VCD info: dumpfile tb_ternary_operator_mux.vcd opened for output.
$ gtkwave tb_ternary_operator_mux.vcd
```

![](Day4/mux1.PNG)
now run synth for this.

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog ternary_operator_mux.v 
yosys> synth -top ternary_operator_mux
...
=== ternary_operator_mux ===

   Number of wires:                  4
   Number of wire bits:              4
   Number of public wires:           4
   Number of public wire bits:       4
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_MUX_                          1
     
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> write_verilog -noattr ternary_operator_mux_net.v
yosys> show
```

![](Day4/mux1s.PNG)

Run GLS.

```
$ iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v
 ./a.out 
VCD info: dumpfile tb_ternary_operator_mux.vcd opened for output.
$ gtkwave tb_ternary_operator_mux.vcd
```

![](Day4/mux1sim.PNG)

Test bad_mux:
```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
        if(sel)
                y <= i1;
        else
                y <= i0;
end
endmodule
```

iverilog:
```
$ iverilog bad_mux.v tb_bad_mux.v
$ ./a.out 
VCD info: dumpfile tb_bad_mux.vcd opened for output.
$ gtkwave tb_bad_mux.vcd
```

Looks like it don't woek as mux.

![](Day4/bad_mux1.PNG)

Now run synth.
```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog bad_mux.v
yosys> synth -top bad_mux
...
=== bad_mux ===

   Number of wires:                  4
   Number of wire bits:              4
   Number of public wires:           4
   Number of public wire bits:       4
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  1
     $_MUX_                          1

yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> write_verilog -noattr bad_mux_net.v


$ iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v
$ ./a.out 
VCD info: dumpfile tb_bad_mux.vcd opened for output.
$ gtkwave tb_bad_mux.vcd

```

![](Day4/bad_mux2.PNG)

Example blocking_caveat:

```
module blocking_caveat (input a , input b , input  c, output reg d);
reg x;
always @ (*)
begin
        d = x & c;
        x = a | b;
end
endmodule

```
![](Day4/blocking1.PNG)

```
$ iverilog blocking_caveat.v tb_blocking_caveat.v 
 ./a.out 
VCD info: dumpfile tb_blocking_caveat.vcd opened for output.

$ gtkwave tb_blocking_caveat.vcd&
```

Looks like it look for post value 
![](Day4/blocking2.PNG)

```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> read_verilog blocking_caveat.v
yosys> synth -top blocking_caveat
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> write_verilog -noattr blocking_caveat_net.v
```
![](Day4/blocking3.PNG)

Run GLS:
```
$ iverilog ../my_lib/verilog_model/primitives.v  ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v
$ ./a.out 
VCD info: dumpfile tb_blocking_caveat.vcd opened for output.
$ gtkwave tb_blocking_caveat.vcd&
```
Compare outputs of 
![](Day4/blocking4.PNG)


# Day 5

# Design Name

As a project, I wanted to choose a relatively simple layout that on the one hand will allow me to familiarize myself with the entire flow and on the other hand will not take me a lot of time to analyze and implement it.

I choose one of the proposed projects:

## iiitb_freqdiv - Frequency Divider
This is a frequency divider model which provide frequency division upto 16 of the input clock.

https://github.com/DantuNandiniDevi/iiitb_freqdiv

# Day 6